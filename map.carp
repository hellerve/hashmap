(use Array)

(definterface hash (Fn [a] Int))

(defmodule String
  (defn rehash [k l]
    (let-do [a 31415
             b 27183
             vh 0]
      (for [x 0 (count k)]
        (do
          (set! &vh (+ (* a (* vh l)) (Char.to-int (char-at k x))))
          (set! &a (* a b))
          (set! &x (Int.inc x))))
      (Int.abs vh)))

  (defn hash [k]
    (rehash k 1))
)

(defmodule Int
  (defn hash [k] k)
)

(defmodule Long
  (defn hash [k] (to-int k))
)

(defmodule Bool
  (defn hash [k] (if k 1 0))
)

(defmodule Char
  (defn hash [k] (to-int k))
)

(defmodule Float
  (defn hash [k] 0)
)

(defmodule Double
  (defn hash [k] 0)
)

(deftype (Entry a b) [key a value b])
(deftype (Bucket a b) [capacity Int, length Int, entries (Array (Entry a b))])

(defmodule Bucket
  (defn empty []
    (Bucket.init 8 0 (Array.allocate 8)))

  (defn growth-fn [b]
    (if (= @(length &b) @(capacity &b))
      (let-do [new-entries (Array.allocate (* 2 @(capacity &b)))]
        (for [i 0 @(length &b)]
          (aset! &new-entries i @(nth (entries &b) i)))
        (=> @&b
            (set-capacity (* 2 @(capacity &b)))
            (set-entries new-entries)))
      b))

  (defn grow-entries [b e]
    (set-entries @&b (aset @(entries &b) @(length &b) e)))

  (defn grow [b e]
    (=> @b
        (growth-fn)
        (grow-entries e)
        (update-length Int.inc)))

  (defn get [b k d]
    (let-do [e d
             len @(length b)
             es (entries b)]
      (for [i 0 len]
        (when (= (Entry.key (nth es i)) k)
          (do
            (set! &e (Entry.value (nth es i)))
            (break))))
       @e))

  (defn contains? [b k]
    (let-do [e false
             len @(length b)
             es (entries b)]
      (for [i 0 len]
        (when (= (Entry.key (nth es i)) k)
          (do
            (set! &e true)
            (break))))
       e))

  (defn remove [entries len capacity k]
    (let-do [nentries (Array.allocate capacity)
             w 0]
      (for [i 0 len]
        (let [e (nth entries i)]
          (unless (= (Entry.key e) k)
            (do
              (aset! &nentries w @e)
              (set! &w (Int.inc w))))))
      nentries))

  (defn shrink-fn [b]
    (if (< @(length &b) (/ @(capacity &b) 4))
      (let-do [new-entries (Array.allocate (/ @(capacity &b) 2))]
        (for [i 0 @(length &b)]
          (aset! &new-entries i @(nth (entries &b) i)))
        (=> @&b
            (set-capacity (/ @(capacity &b) 2))
            (set-entries new-entries)))
      b))

  (defn shrink [b k]
    (if (contains? b k)
      (=> @b
          (set-entries (remove (entries b) @(length b) @(capacity b) k))
          (update-length Int.dec)
          (shrink-fn))
      @b))

)

(deftype (Map a b) [dflt String n-buckets Int buckets (Array (Bucket a b))])

(defmodule Map
  (defn create [n-buckets]
    (init @"" n-buckets (repeat n-buckets Bucket.empty)))

  (defn create-default [n-buckets dflt]
    (init dflt n-buckets (repeat n-buckets Bucket.empty)))

  (defn put [m k v]
    (let [idx (Int.mod (hash k) @(n-buckets &m))
          b (buckets &m)]
      (set-buckets m (aset @b
                           idx
                           (Bucket.grow (nth b idx) (Entry.init @k @v))))))

  (defn get [m k]
    (let [idx (Int.mod (hash k) @(n-buckets m))]
      (Bucket.get (nth (buckets m) idx) k (dflt m))))

  (defn count [m]
    (let-do [c 0]
      (for [i 0 @(n-buckets m)]
        (set! &c (+ c @(Bucket.length (nth (buckets m) i)))))
      c))

  (defn empty? [m]
    (= (count m) 0))

  (defn contains? [m k]
    (let [idx (Int.mod (hash k) @(n-buckets m))]
      (Bucket.contains? (nth (buckets m) idx) k)))

  (defn remove [m k]
    (let [idx (Int.mod (hash k) @(n-buckets &m))
          b (buckets &m)]
      (set-buckets m (aset @b
                           idx
                           (Bucket.shrink (nth b idx) k)))))


  (defn for-each [m f]
    (for [i 0 @(n-buckets m)]
      (let [bucket (nth (buckets m) i)
            len @(Bucket.length bucket)
            entries (Bucket.entries bucket)]
        (for [j 0 len]
          (let [e (nth entries j)]
            (f (Entry.key e) (Entry.value e)))))))
)
